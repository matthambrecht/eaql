// "and" keyword requires us to open an and node and continue parsing from
// there
def handle_and():
    return Op {
        _type: "AND",
        _ls: recurse_down(),
        _rs: recurse_down()
    }

// If we see an "or" we need to let recurse down know to close
// things out until we see an "open" "OR" node
def handle_or():
    set closing_or = True
    return handle_close()

// If we see an opening parentheses we open an "OR" node
def handle_open_paren():
    set ret = Op {
        _type: "OR",
        _ls: recurse_down(),
        _rs: recurse_down()
    }

    // After we are done parsing the open parentheses's tree we need
    // to check if add an "AND" if the next keyword is "and" and start parsing
    // on the right or "OR" if the next keyword is "or". If the next keyword
    // is another closing parentheses we can continue as normal.
    if tok == AND_TOK:
        *idx += 1

        return Op {
            _type: "AND",
            _ls: ret,
            _rs: recurse_down()
        }
    else if tok == OR_TOK:
        *idx += 1    

        return Op {
            _type: "OR",
            _ls: ret,
            _rs: recurse_down()
        }
    else if tok == CLOSE_PAREN:
        *idx += 1

        return ret
    else:
        return Err("Something went wrong parsing a nested conditional, expected a closing parentheses, 'and' or 'or', but got '{token}' instead.")

// Hanlde closing paren
def handle_close_paren():
    set closing_paren = True

// This is just a helper that defaults nodes for us to booleans
// when "closing" out
def handle_close():
    return parent_node == "AND" ? Bool(True) : Bool(False)

// When get a literal token we add an "AND" node and evaluate the base expression
// to the left of that node, while continuing our parsing on the right
def handle_literal():
    set ls = ExpressionNode::parse_child();
    *idx += 1;
    set rs = recurse_down();

    return Op {
        _type: "AND"
        _ls: ls,
        _rs: rs,
    }

def parse_child():
    if tok == AND_TOK:
        *idx += 1

        return handle_and()

    else if tok == OR_TOK:
        *idx += 1

        return handle_or()

    else if tok == OPEN_PAREN:
        *idx += 1

        return handle_open_paren()

    else if tok == CLOSE_PAREN:
        *idx += 1

        return handle_close_paren()

    else if tok == END_OF_CONDITIONAL:
        *idx += 1

        if closing_paren:
            return Err("Found end of conditional, but there was an unclosed parentheses!")

        set finished = True

        return handle_close()

    else if tok == LITERAL:
        return handle_literal()

    else:
        Err("Unexpected token while parsing conditional expresion -> {token}")

def recurse_down():
    // We aren't finished yet so we might need to parse
    // properly
    if finished:
        return hanndle_close()
    
    // If we have seen a closing or we need to close out
    // unless our parent node is an OR, then we need to add
    // and OR node and begin parsing from there
    if closing_paren:
        return handle_close()
    else if closing_or:
        if parent_node == "OR":
            set closing_or = False

            return Op {
                _type: "OR",
                _ls: recurse_down(),
                _rs: recurse_down()
            }
        else:
            return handle_close()

    return parse_child()

def parse_conditional():
    return Op {
        type: "OR",
        _ls: recurse_down(),
        _rs: recurse_down()
    }